#version 450

layout (local_size_x = 10, local_size_y = 10, local_size_z = 1) in; // At least 1 for each local size

layout(set = 0, binding = 0) uniform sampler3D volumnSampler; // Stores 3D intensities, [0, 1] * color white, not alpha

layout(set = 0, binding = 1, rgba8) uniform writeonly image2D raycastedImage;

struct Ray
{
	vec3 origin;
	vec3 directionTrueLength;
	// vec3 directionNormalized;
};

// Fixed transfer fuction for testing
// Transfer function from ImGUI
// layout(set 0, binding = ...) uniform dynamic sampler4D volumnColor; f(intensity) = color
// layout(set 0, binding = ...) uniform dynamic sampler2D volumnAlpha; f(intensity) = alpha
vec3 toColor(float intensity)
{
	// intensity = [0, 1]
	const float pi = acos(-1);
	float red = clamp(sin(intensity * 2.0 * pi), 0.0, 1.0);
	float green = clamp(sin((intensity - (1.0 / 4.0)) * 2.0 * pi), 0.0, 1.0);
	float blue = clamp(sin((intensity  - (1.0 / 2.0)) * 2.0 * pi), 0.0, 1.0);
	return vec3(red, green, blue);
}
float toAlpha(float intensity)
{
	// return 1; // Uniform
	// intensity = [0, 1]
	return intensity;
}

vec4 visualizeDirection(int direction) // Return the color for this pixel based on the direction, default is 0
{
	// direction = 0 (default, bottom-up?/top-down?)
	//           = 1 (sideway)
	ivec2 imageDimension = imageSize(raycastedImage);
	ivec3 textureDimension = textureSize(volumnSampler, 0);

	ivec2 pixelLocation = ivec2(gl_GlobalInvocationID.xy); // This pixel location
	vec2 normalizedPixelLocation = pixelLocation / vec2(imageDimension.x - 1, imageDimension.y - 1); // Normalize the pixel location for testing

	// float slide = 40.0f / 112.0f; // [0, 112] slides, normalized to [0.0, 1.0]
	float slide = 0.5f;
	vec4 sampled = texture(volumnSampler, vec3(normalizedPixelLocation, slide)); // U, V, W
	float intensity = sampled.x; // Only the intensity color value is recorded in the first component
	return vec4(intensity, intensity, intensity, 1.0f); // Gray scale
}

void main()
{
	// Orthographic projection, with the box dimension beside its depth equals to the image dimension

	const vec4 pixelViewportLocation = vec4(gl_GlobalInvocationID.xy, 0.0, 1.0); // Pixel location in viewport space

	// Pixel to world space
	const vec2 imageDimension = imageSize(raycastedImage) - 1; // [0, W) x [0, H)
	const mat4 normalizeComponents = mat4(vec4(1 / imageDimension.x, 0, 0, 0), vec4(0, 1 / imageDimension.y, 0, 0), vec4(0, 0, 1, 0), vec4(0, 0, 0, 1));
	const mat4 viewportToWorld = mat4(vec4(1, 0, 0, 0), vec4(0, -1, 0, 0), vec4(0, 0, 1, 0), vec4(0, 0, 0, 1)); // 2 columns, 4 rows
	const mat4 centerAtOrigin = mat4(vec4(1, 0, 0, 0), vec4(0, 1, 0, 0), vec4(0, 0, 1, 0), vec4(-0.5, 0.5, 0, 1)); // Each vec4 represent a column

	vec4 pixelWorldLocation = centerAtOrigin * viewportToWorld * normalizeComponents * pixelViewportLocation;
	// proxyImageOrigin   = (-0.5, 0.5, 0.0)
	// Image proxy width  = [-0.5, -0.5] = 1
	// Image proxy height =  [0.5, -0.5] = 1

	// Setup a proxy volumn origin. The dimension of the volumn is equal to the imageDimension with the depth of 1, ie [0, 1]
	const vec3 volumeDimension = textureSize(volumnSampler, 0) - 1; // [0, W) x [0, H) x [0, D)
	vec3 proxyVolumeOrigin = vec3(-0.5, 0.5, -1.0); // Proxy volume dimension [0, 1]^3, this origin is at the front top left
	// Proxy volume width  =  [-0.5, 0.5] = 1
	// Proxy volume height =  [0.5, -0.5] = 1
	// Proxy volume depth  = [-1.0, -2.0] = 1

	uint samples = 10; // Plus 1 extra for t = 0
	vec3 pixelColor = vec3(0);

	const vec3 frontHit = vec3(pixelWorldLocation.xy, -1.0); // Shifted -1.0 in the z direction
	const vec3 backHit = vec3(pixelWorldLocation.xy, -2.0); // boxDepth
	const Ray raycast = Ray(frontHit, backHit - frontHit);

	// Back to front, recursive approach
	for (int t = int(samples); t >= 0; t--) // Includes [samples, 0]
	{
		float tNorm = t / float(samples);
		const vec3 sampleLocation = vec3(raycast.origin + raycast.directionTrueLength * tNorm);
		const vec4 sampledIntensity = texture(volumnSampler, abs(sampleLocation - proxyVolumeOrigin));
		const float intensity = sampledIntensity.x;

		if (tNorm == 1.0) // Back
		{
			pixelColor = toColor(intensity);
		}
		else // Going to the front
		{
			pixelColor = toColor(intensity) + (1 - toAlpha(intensity)) * pixelColor;
		}
	}

	imageStore(raycastedImage, ivec2(pixelViewportLocation.xy), vec4(pixelColor, 1.0));
}

