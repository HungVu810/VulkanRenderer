#version 450

layout (local_size_x = 10, local_size_y = 10, local_size_z = 1) in; // At least 1 for each local size

layout(set = 0, binding = 0) uniform sampler3D volumnSampler; // Stores 3D intensities, [0, 1] * color white, not alpha

layout(set = 0, binding = 2) uniform sampler1D transferSampler;

layout(set = 0, binding = 1, rgba8) uniform writeonly image2D raycastedImage;


// layout() dynamic sampler1D transferFunciton; // a texture 256 pixels,

struct ViewPyramid
{
	vec3 location; // Top of the pyramid (camera, the apex)
	float height; // Length from the top to the base of the pyramid (image grid)
	// Camera unit vectors
	vec3 side;
	vec3 up;
	vec3 forward; // Looking direction
};

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct HitInfo
{
	bool isHit;
	float tMin, tMax; // Scale a ray's direction to the 2 hit locations, what if only one hit ?
};

struct Slab
{
	vec3 normal;
	vec3 point;
};

float intersectSlab(Ray ray, Slab slab)
{
	return dot(slab.normal, slab.point - ray.origin) / dot(slab.normal, ray.direction);
}

// volumeMin and volumeMax denotes 2 extremes of a volume. The volume must be an
// axis-aligned bouding box since this function logic is based on these facts:
// X slabs (volumeMin.x, volumeMax.x) has their normal (1, 0, 0).
// Y slabs (volumeMin.y, volumeMax.y) has their normal (0, 1, 0).
// Z slabs (volumeMin.z, volumeMax.z) has their normal (0, 0, -1) which goes into the screen.
HitInfo intersect(Ray ray, vec3 volumeMin, vec3 volumeMax)
{
	const Slab slabMinX = Slab(vec3(1, 0, 0), vec3(volumeMin.x, 0, 0));
	const Slab slabMaxX = Slab(vec3(1, 0, 0), vec3(volumeMax.x, 0, 0));

	const Slab slabMinY = Slab(vec3(0, 1, 0), vec3(0, volumeMin.y, 0));
	const Slab slabMaxY = Slab(vec3(0, 1, 0), vec3(0, volumeMax.y, 0));

	const Slab slabMinZ = Slab(vec3(0, 0, -1), vec3(0, 0, volumeMin.z));
	const Slab slabMaxZ = Slab(vec3(0, 0, -1), vec3(0, 0, volumeMax.z));

	float tOne = intersectSlab(ray, slabMinX);
	float tTwo = intersectSlab(ray, slabMaxX);
	const float tMinX = min(tOne, tTwo);
	const float tMaxX = max(tOne, tTwo);

	tOne = intersectSlab(ray, slabMinY);
	tTwo = intersectSlab(ray, slabMaxY);
	const float tMinY = min(tOne, tTwo);
	const float tMaxY = max(tOne, tTwo);

	tOne = intersectSlab(ray, slabMinZ);
	tTwo = intersectSlab(ray, slabMaxZ);
	const float tMinZ = min(tOne, tTwo);
	const float tMaxZ = max(tOne, tTwo);

	const float tMin = max(max(tMinX, tMinY), tMinZ);
	const float tMax = min(min(tMaxX, tMaxY), tMaxZ);

	// If not hit, set the color to the clear color value
	// tMin > tMax -> Ray misses the box
	// tMax < 0 -> The box is behind the ray
	if (tMin > tMax || tMax < 0) return HitInfo(false, tMin, tMax);
	else return HitInfo(true, tMin, tMax);
	// If HitInfo return true, either:
	// tMin < 0 && tMax > 0, tMin < tMax -> The ray origin is inside the box, using the ray position as tMin to sample the volume
	// tMin > 0 && tMax > 0, tMin < tMax -> tMin and tMax can be used for sample the volume
}

// Fixed transfer fuction for testing
// Transfer function from ImGUI
// layout(set 0, binding = ...) uniform dynamic sampler4D volumnColor; f(intensity) = color
// layout(set 0, binding = ...) uniform dynamic sampler2D volumnAlpha; f(intensity) = alpha
vec3 toColor(float intensity) // intensity = [0, 1]
{
//	const float pi = acos(-1);
//	float red = clamp(sin(intensity * 2.0 * pi), 0.0, 1.0);
//	float green = clamp(sin((intensity - (1.0 / 4.0)) * 2.0 * pi), 0.0, 1.0);
//	float blue = clamp(sin((intensity  - (1.0 / 2.0)) * 2.0 * pi), 0.0, 1.0);
//	return vec3(red, green, blue);
//
	return texture(transferSampler, intensity).xyz;
}

float toAlpha(float intensity) // intensity = [0, 1]
{
	// return 1; // Uniform
	// return intensity;
	return texture(transferSampler, intensity).w;
}

ViewPyramid initViewPyramid()
{
	const vec3 viewPyramidForward = vec3(0, 0, -1); // Negative z axis forward in global world basis
	const vec3 viewPyramidUp = vec3(0, 1, 0);
	const vec3 viewPyramidSide = cross(viewPyramidForward, viewPyramidUp);
	// The corners are the side of the cube if the image suddenly has edge corners due to perespective projection when adjusting the viewPyramidLocation/viewPyramidHeight
	const vec3 viewPyramidLocation = vec3(0, -5, -0.5); // -0.5 z in the middle of the volume sample space
	//const vec3 viewPyramidLocation = vec3(0, 0, 5); // -0.5 z in the middle of the volume sample space
	const float viewPyramidHeight = 5; // The base of the view pyramid should be ideally right on top of the side of the sampled volume

	// To rotate the viewPyramid forward, up and side 
	// Because the volume dimension is 1, rotating radian need to be small to compensate
	const float pi = acos(-1);
	const float pitchRad = pi / 2; // Around X
	//const float pitchRad = 0; // Around X
	const float yawRad = 0; // Around Y
	const float rollRad = 0; // Around Z

	const mat4 pitch = mat4(vec4(1, 0, 0, 0)
						  , vec4(0, cos(pitchRad), sin(pitchRad), 0)
						  , vec4(0, -sin(pitchRad), cos(pitchRad), 0)
						  , vec4(0, 0, 0, 1));
	const mat4 yaw = mat4(vec4(cos(yawRad), 0, -sin(yawRad), 0)
						, vec4(0, 1, 0, 0)
						, vec4(sin(yawRad), 0, cos(yawRad), 0)
						, vec4(0, 0, 0, 1));
	const mat4 roll = mat4(vec4(cos(rollRad), sin(rollRad), 0, 0)
						 , vec4(-sin(rollRad), cos(rollRad), 0, 0)
						 , vec4(0, 0, 1, 0)
						 , vec4(0, 0, 0, 1));

	const mat4 viewPyramidBasis = mat4(vec4(viewPyramidSide, 0) // The default view basis orientation
						             , vec4(viewPyramidUp, 0)
						             , vec4(viewPyramidForward, 0)
						             , vec4(0, 0, 0, 1));

	const mat4 rotatedViewPyramidBasis = roll * yaw * pitch * viewPyramidBasis; // Could just use roll/yaw/pitch if the forward axis is +z

	return ViewPyramid(viewPyramidLocation, viewPyramidHeight, rotatedViewPyramidBasis[0].xyz, rotatedViewPyramidBasis[1].xyz,  rotatedViewPyramidBasis[2].xyz);
}

vec3 toWorldSpace(ivec2 pixelViewportLocation, ViewPyramid viewPyramid)
{
	// Pixel to world space
	const vec2 imageDimension = imageSize(raycastedImage) - 1; // [0, W) x [0, H)
	// Each vec represent a column
	const mat4 normalizeComponents = mat4(vec4(1 / float(imageDimension.x), 0, 0, 0)
										, vec4(0, 1 / imageDimension.y, 0, 0)
										, vec4(0, 0, 1, 0)
										, vec4(0, 0, 0, 1)); // [0, W) x [0, H) -> [0, 1]^2
	const mat4 viewportToWorld = mat4(vec4(1, 0, 0, 0)
									, vec4(0, -1, 0, 0)
									, vec4(0, 0, 1, 0)
									, vec4(0, 0, 0, 1)); // [0, 1]^2 -> x : [0, 1], y : [0, -1]
	const mat4 translatePreRotate = mat4(vec4(1, 0, 0, 0)
							           , vec4(0, 1, 0, 0)
							           , vec4(0, 0, 1, 0)
							           , vec4(-0.5, 0.5, 0, 1)); // Shift x by -0.5, y by 0.5 (image grid to the center of the XY basis), and z by 1 (out of the screen). Center the image grid in the world basis
	const mat4 rotate = mat4(vec4(viewPyramid.side, 0)
						   , vec4(viewPyramid.up, 0)
						   , vec4(viewPyramid.forward, 0)
						   , vec4(0, 0, 0, 1));
	const mat4 translatePostRotate = mat4(vec4(1, 0, 0, 0)
							            , vec4(0, 1, 0, 0)
							            , vec4(0, 0, 1, 0)
							            , vec4(viewPyramid.location + viewPyramid.height * viewPyramid.forward, 1)); // Translate the pixel so that the image grid is centered with respect to the view pyramid
	// proxyImageOrigin   = (-0.5, 0.5, 0.0)
	// Image proxy width  = [-0.5, -0.5] = 1
	// Image proxy height =  [0.5, -0.5] = 1
	vec4 pixelWorldLocation = translatePostRotate * rotate * translatePreRotate * viewportToWorld * normalizeComponents * vec4(pixelViewportLocation, 0, 1);
	return pixelWorldLocation.xyz;
}

void main()
{
	// NOW: Orthographic projection, with the box dimension beside its depth equals to the image dimension
	// TODO: Perspective projection, switchable with ortho

	// TODOOOOOOOOOO:
	// Put the pixel transformation in a descriptor
	// Dynamic Transfer function

	ViewPyramid viewPyramid = initViewPyramid();

	// Viewport space [0, 1]^2
	const ivec2 pixelViewportLocation = ivec2(gl_GlobalInvocationID.xy); // Pixel location in viewport space
	const vec3 pixelWorldLocation = toWorldSpace(pixelViewportLocation, viewPyramid);

	// Setup a proxy volumn origin. The dimension of the volumn matches with the sampler space [0, 1]^3
	// Proxy volume width  = volumeMax.x - volumeMin.x == 1
	// Proxy volume height = volumeMax.y - volumeMin.y == 1
	// Proxy volume depth  = volumeMax.z - volumeMin.z == 1
	const vec3 volumeMin = vec3(-0.5, -0.5, -1); // Proxy volume origin, bottom left corner at the back
	const vec3 volumeMax = vec3(0.5, 0.5, 0);
	const vec3 volumeOrigin = vec3(-0.5, -0.5, 0); // Front top left, like sampler space

	// TODO: don't do the proxy transformation, instead transform the camera postion and looking direction, make sure to update the projected image grid oritentaiton as well
	// Camera has its own cooridate, seperated from the world cooridnate
	// Camera transformation matrix is given to the image grid as well

	uint samples = 254; // The samples >= 0 within the 2 defaults samples at each extremes tMin and tMax, 113 slides
	vec3 clearColor = vec3(0, 0, 0); // For pixels that doesn't hit
	vec3 pixelColor = vec3(0);

	const Ray raycast = Ray(viewPyramid.location, normalize(pixelWorldLocation - viewPyramid.location)); // If doing orthographic, the pixel direction == viewPyramid.forward
	const HitInfo hitInfo = intersect(raycast, volumeMin, volumeMax);

	if (!hitInfo.isHit) pixelColor = clearColor; // TODO: The outter pixels doesn't hit with the default pixel transform?
	else
	{
		// Back to front, recursive approach
		const float stepSize = (hitInfo.tMax - hitInfo.tMin) / (samples + 1);
		for (int t = 0; t <= (samples + 1); t++)
		{
			const vec3 directionTrueLength = (hitInfo.tMax - t * stepSize) * raycast.direction; // (hitInfo.tMax - t * stepSize): hitInfo.tMax -> hitInfo.tMin
			const vec3 sampleLocation = vec3(raycast.origin + directionTrueLength);
			const vec4 sampledIntensity = texture(volumnSampler, abs(sampleLocation - volumeOrigin));
			const float intensity = sampledIntensity.x;
			if (t == 0) // The back
			{
				pixelColor = toColor(intensity);
			}
			else // Going to the front
			{
				pixelColor = toColor(intensity) + (1 - toAlpha(intensity)) * pixelColor;
			}
		}
	}


	imageStore(raycastedImage, pixelViewportLocation, vec4(pixelColor, 1.0));
}

