#version 450

layout (local_size_x = 10, local_size_y = 10, local_size_z = 1) in; // At least 1 for each local size

layout(set = 0, binding = 0) uniform sampler3D volumnSampler; // Stores 3D intensities, [0, 1] * color white, not alpha

// Transfer function from ImGUI
// layout(set 0, binding = ...) uniform dynamic sampler4D volumnColor; f(intensity) = color
// layout(set 0, binding = ...) uniform dynamic sampler2D volumnAlpha; f(intensity) = alpha

layout(set = 0, binding = 1, rgba8) uniform writeonly image2D raycastedImage;

// Fixed transfer fuction for testing
//vec3 sampleColor(float intensity)
//{
//}
//
//float sampleAlpha(float intensity)
//{
//}
//

// TODO: Orthographic projection, perspective projection later

// augment the uv with world space and the volumnSampler with world space coordinate (x,y,z)
// descriptor of the width and height of the screen (push constant?)
// volume data is passed as a descriptor as well
// f(width_x, height_y) -> world space x, y
// perform ray cast from those x, y
// run the compute shader in parallel each pixel, instead of going through each of them one by one
// TODO: how to present the image in the compute shader after finished ray castingn?

//[[nodiscard]] inline auto getIntensity(std::span<Intensity, NUM_INTENSITIES> slides, int z, int y, int x)
//{
//	return slides[(z * SLIDE_HEIGHT * SLIDE_WIDTH) + (y * SLIDE_WIDTH) + x];
// }


void main()
{
	// ivec2 localInvocXY = ivec2(gl_GlobalInvocationID.xy) / imageDimension; // Local invocation x,y?
	ivec2 imageDimension = imageSize(raycastedImage);
	ivec2 pixelLocation = ivec2(gl_GlobalInvocationID.xy); // This pixel location
	vec2 normalizedPixelLocation = pixelLocation / vec2(imageDimension.x - 1, imageDimension.y - 1); // Normalize the pixel location for testing

	float testSlide = 40.0f / 112.0f; // [0, 112] slides
	vec4 sampled = texture(volumnSampler, vec3(normalizedPixelLocation, testSlide));
	float intensity = sampled.x; // Only the intensity color value is recorded in the first component

	// vec4 color = vec4(0.5f, 0.0f, 0.0f, 0.0f); // R8G8B8A8
	vec4 testColor = vec4(intensity, intensity, intensity, 1.0f);
	imageStore(raycastedImage, pixelLocation, testColor);
}

// for each pixel assign a flat color then transfer it over to a swapchain image for testing
// then assign the color value each pixel in a descriptor storage buffer
